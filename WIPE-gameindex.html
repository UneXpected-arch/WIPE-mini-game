<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>WIPE: Catch The Gains</title>
<style>
  :root { --bg:#0f2342; --tile:#122b52; --accent:#19d38b; --gold:#f6c445; --text:#f7f7f7; }
  html,body { margin:0; height:100%; background:var(--bg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial; color:var(--text); }
  #ui { position:fixed; inset:0; pointer-events:none; }
  .hud { position:absolute; left:16px; top:12px; font-weight:700; text-shadow:0 2px 6px rgba(0,0,0,.35); }
  .hud span { margin-right:16px; }
  .center { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; text-align:center; }
  .panel { pointer-events:auto; background:rgba(18,43,82,.9); border:1px solid rgba(255,255,255,.12);
           border-radius:16px; padding:24px 20px; max-width:520px; }
  button { pointer-events:auto; cursor:pointer; border:0; border-radius:12px; padding:12px 18px; font-weight:700; }
  .primary { background:var(--accent); color:#061b2c; }
  canvas { display:block; width:100%; height:100vh; image-rendering:pixelated; background:
    radial-gradient(1200px 600px at 50% -10%, #1c396b 0%, #0f2342 60%),
    repeating-linear-gradient(0deg, var(--tile), var(--tile) 28px, #0f2342 28px, #0f2342 56px); }
  .credits { position:absolute; right:12px; bottom:10px; font-size:12px; opacity:.7 }
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="ui">
  <div class="hud"><span id="score">Score: 0</span><span id="combo">Combo: x1</span><span id="lives">Lives: 3</span></div>
  <div id="start" class="center">
    <div class="panel">
      <h1>WIPE: Catch the Gains üßªüí∞</h1>
      <p>Move the TP roll to <b>catch coins</b>.<br>Miss 3 and it‚Äôs <i>game over</i>.</p>
      <p>Controls: <b>Drag / Touch</b> or <b>‚Üê ‚Üí</b></p>
      <button id="startBtn" class="primary">Start</button>
    </div>
  </div>
  <div id="gameover" class="center" style="display:none;">
    <div class="panel">
      <h2>Flushed‚Ä¶ üíÄ</h2>
      <p id="final"></p>
      <button id="again" class="primary">Play Again</button>
    </div>
  </div>
  <div class="credits">WIPE mini-game demo</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // --- helpers
  const rand = (a,b)=>Math.random()*(b-a)+a;
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

  // --- resize
  function fit() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', fit, {passive:true}); fit();

  // --- game state
  const state = {
    running:false, over:false,
    score:0, combo:1, lives:3, best:0,
    time:0, spawnTimer:0, spawnRate:800, speed:220,
    coins:[],
    tp:{ x:window.innerWidth*0.5, y:window.innerHeight-90, w:180, h:36, vx:0 }
  };

  // --- UI refs
  const $score = document.getElementById('score');
  const $combo = document.getElementById('combo');
  const $lives = document.getElementById('lives');
  const $start = document.getElementById('start');
  const $startBtn = document.getElementById('startBtn');
  const $over = document.getElementById('gameover');
  const $final = document.getElementById('final');
  const $again = document.getElementById('again');

  function reset() {
    state.score=0; state.combo=1; state.lives=3;
    state.coins.length=0; state.time=0;
    state.spawnTimer=0; state.spawnRate=800; state.speed=220;
    state.tp.x = canvas.width/2;
  }

  function start() {
    reset();
    state.running=true; state.over=false;
    $start.style.display='none';
    $over.style.display='none';
    last=performance.now();
    requestAnimationFrame(loop);
  }

  function gameOver() {
    state.running=false; state.over=true;
    state.best = Math.max(state.best, state.score);
    $final.textContent = `Score: ${state.score}  ‚Ä¢  Best: ${state.best}`;
    $over.style.display='flex';
  }

  $startBtn.onclick = start;
  $again.onclick = start;

  // --- input
  let dragging=false, dragOffset=0;
  canvas.addEventListener('pointerdown', e=>{
    const x = e.clientX;
    if (x > state.tp.x - state.tp.w/2 && x < state.tp.x + state.tp.w/2) {
      dragging=true; dragOffset = x - state.tp.x;
    } else { dragging=true; dragOffset=0; }
  });
  window.addEventListener('pointermove', e=>{
    if (!dragging) return;
    state.tp.x = clamp(e.clientX - dragOffset, state.tp.w/2, canvas.width - state.tp.w/2);
  });
  window.addEventListener('pointerup', ()=> dragging=false);

  const keys={};
  window.addEventListener('keydown', e=>{ keys[e.key]=true; });
  window.addEventListener('keyup', e=>{ keys[e.key]=false; });

  // --- coin spawns
  function spawn() {
    const rare = Math.random() < 0.08; // diamond coin chance
    state.coins.push({
      x: rand(40, canvas.width-40),
      y: -30,
      r: rare ? 24 : 18,
      v: state.speed * (rare ? 0.95 : 1),
      type: rare ? 'diamond' : 'gold',
      rot: rand(0, Math.PI*2),
    });
  }

  // --- collision
  function overlaps(coin, tp) {
    // circle-rect collision (approx)
    const cx = clamp(coin.x, tp.x - tp.w/2, tp.x + tp.w/2);
    const cy = clamp(coin.y, tp.y - tp.h/2, tp.y + tp.h/2);
    const dx = coin.x - cx, dy = coin.y - cy;
    return (dx*dx + dy*dy) <= (coin.r*coin.r);
  }

  // --- rendering helpers
  function drawTP(tp) {
    const {x,y,w,h} = tp;
    // roll
    ctx.save();
    ctx.translate(x, y);
    // paper
    ctx.fillStyle = '#f1f4f8';
    ctx.strokeStyle = 'rgba(0,0,0,.25)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(-w/2, -h/2, w, h, 18);
    ctx.fill(); ctx.stroke();

    // inner tube
    ctx.fillStyle = '#b8894d';
    ctx.beginPath();
    ctx.ellipse(-w*0.35, 0, 14, 14, 0, 0, Math.PI*2);
    ctx.fill();

    // WIPE text watermark
    ctx.fillStyle = 'rgba(0,0,0,.15)';
    ctx.font = 'bold 18px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('WIPE', 0, 6);
    ctx.restore();
  }

  function drawCoin(c) {
    ctx.save();
    ctx.translate(c.x, c.y);
    ctx.rotate(c.rot);
    if (c.type==='diamond') {
      // diamond coin
      ctx.fillStyle = '#b6f0ff';
      ctx.strokeStyle = '#88d7ea';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, -c.r);
      ctx.lineTo(c.r*0.9, 0);
      ctx.lineTo(0, c.r);
      ctx.lineTo(-c.r*0.9, 0);
      ctx.closePath();
      ctx.fill(); ctx.stroke();
      ctx.fillStyle='#0a3a4a';
      ctx.font='bold 12px system-ui';
      ctx.textAlign='center';
      ctx.fillText('+100', 0, 4);
    } else {
      // gold coin
      const grad = ctx.createRadialGradient(-5,-5,4,0,0,c.r+6);
      grad.addColorStop(0,'#fff5b2');
      grad.addColorStop(1,'#f6c445');
      ctx.fillStyle = grad;
      ctx.strokeStyle = '#b98513';
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(0,0,c.r,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.fillStyle='#7f5a0a';
      ctx.font='bold 14px system-ui';
      ctx.textAlign='center';
      ctx.fillText('$', 0, 5);
    }
    ctx.restore();
  }

  // --- loop
  let last = 0;
  function loop(t) {
    if (!state.running) return;
    const dt = Math.min(32, t - last) / 1000;
    last = t;
    state.time += dt;
    state.spawnTimer += dt*1000;

    // difficulty ramp
    state.speed += dt * 6;
    state.spawnRate = Math.max(260, state.spawnRate - dt * 8);

    if (state.spawnTimer > state.spawnRate) {
      state.spawnTimer = 0;
      spawn();
    }

    // input
    if (keys['ArrowLeft'])  state.tp.x -= 420*dt;
    if (keys['ArrowRight']) state.tp.x += 420*dt;
    state.tp.x = clamp(state.tp.x, state.tp.w/2, canvas.width - state.tp.w/2);

    // update coins
    for (let i=state.coins.length-1; i>=0; i--) {
      const c = state.coins[i];
      c.y += c.v * dt;
      c.rot += (c.type==='diamond'? 2.2:1.4) * dt;
      if (overlaps(c, state.tp)) {
        // caught
        const gained = (c.type==='diamond'? 100 : 10) * state.combo;
        state.score += gained;
        state.combo = Math.min(10, state.combo + 1);
        state.coins.splice(i,1);
      } else if (c.y - c.r > canvas.height) {
        // missed
        state.lives -= 1;
        state.combo = 1;
        state.coins.splice(i,1);
        if (state.lives <= 0) { gameOver(); }
      }
    }

    // draw
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // subtle stars
    ctx.save();
    ctx.globalAlpha = .15;
    for (let i=0;i<60;i++){
      const x = (i*97)%canvas.width, y = (i*53)%canvas.height;
      ctx.fillStyle = i%7? '#ffffff':'#a7d0ff';
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.restore();

    // floor horizon
    ctx.fillStyle = 'rgba(0,0,0,.15)';
    ctx.fillRect(0, canvas.height-6, canvas.width, 6);

    // draw coins and TP
    state.coins.forEach(drawCoin);
    drawTP(state.tp);

    // UI
    $score.textContent = `Score: ${state.score}`;
    $combo.textContent = `Combo: x${state.combo}`;
    $lives.textContent = `Lives: ${state.lives}`;

    requestAnimationFrame(loop);
  }
})();
</script>
</body>
</html>

